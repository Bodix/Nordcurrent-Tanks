# Nordcurrent - Тестове завдання (Танки)

Автор: Богдан Ніколаєв

## Коментарі до проєкту

- В архітектурі проекту закладено можливість швикого налаштування логіки ШІ. Для того, щоб перевірити цю можливість зробіть наступні дії:

  1. Відкрийте сцену `Game`.
  2. Знайдіть на сцені об'єкт `Scene Context`.
  3. Знайдіть на цьому об'єкті компонент `GameSceneInstaller` та замініть в ньому значення серіалізованого поля `Ai Behaviour` з `PeacefulAIBehaviour` на `AggressiveAIBehaviour`.

   Після цього ШІ почне стріляти з рандомізованим інтервалом.
   Діапазон рандомізації інтервалу пострілів можна змінити в налаштуваннях `AggressiveAIBehaviour`.

   В завданні сказано:

   ```text
   Під час розробки гри необхідно закласти наступні архітектурні можливості:
   - зміна модулів ШІ танків;
   - зміна принципу руху і керування (наприклад, роздільне керування гусеницями, тощо);
   - додавання пострілів у танки ШІ.
   ```

   Я зробив зміну поведінки штучного інтелекту за допомогою абстракції `AIBehaviour` (з реалізаціями `PeacefulAIBehaviour` та `AggressiveAIBehaviour`). Думаю, це можна вважати як `модулі ШІ танків`, а також це закриває останній пункт з `додаванням пострілів у танки ШІ`. Також є можливість швидко та просто змінювати конфігурацію ШІ за допомогою `AIConfig`.

   Стосовно `зміни принципу руху і керування`: я не робив явну реалізацію цього, але це дуже просто реалізувати в моїй архитектурі. Для цього треба просто зробити абстракцію руху (наприклад інтерфейс `IMovable` з методами `Move` і `Rotate`), зробити різні реалізації цієї абстракції та інжектувати потрібні реалізації в потрібні об'єкти за допомогою DI. Все по аналогії з `AIBehaviour`, `PeacefulAIBehaviour` та `AggressiveAIBehaviour`.

- В проєкті було використано деякі рішення, які можна розцінювати як надлишкові, а саме:

  - **Zenject (Dependency Injection)**. Я розумію, що для проєкту такого невеликого розміру це зовсім необов`язково, але я зробив це, щоб продемонструвати своє вміння користуватись DI. Також DI, як найкраще рішення для управлінням залежностями, ніколи не буде зайвим.

  - **Сinemachine**. Використав, тому що швидко встановити, швидко налаштувати, а також щоб показати своє вміння користуватись.

  - **Input System**. Для рішення даного тестового завдання можна було обійтись і старою інпут системою, але на сайті **Nordcurrent** я побачив, що компанія створює ігри `for smartphones, tablets, and PC/Mac`, тож вирішив показати вміння користуватися новою інпут системою, за допомогою якої можна відносно зручно робити кросплатформений інпут (однак в моєму рішенні тестового завдання кросплатформеності немає).

- Для ШІ було закладено наступну логіку при колізіях:

  1. При зіткненні з будь-чим (не враховуючи снаряди), ШІ:
     - припиняє постійний рух,
     - припиняє періодичні розвороти,
     - припиняє стріляти (у випадку виокристання `AggressiveAIBehaviour`).

  2. При зіткненні з іншим танком, ШІ розвертається на місці на заданий в конфігі радіус (задано: 90 градусів). Після чого відновлює поведінку, що була припинена в пункті 1.

  3. При зіткненні зі стіною, ШІ розвертається на місці на радіус в діапазоні [135, 179] градусів. Після чого відновлює поведінку, що була припинена в пункті 1. При таких налаштуваннях ШІ:
     - і достатньо відвертається від стіни (щоб не попасти в неї знову),
     - і присутня деяка рандомізація.

      Радіус розвертання складно зробити можливим рівно 180 градусів без додаткової роботи, тому що потрібний Unity API пов'язаний із кутами знаходиться або в діапазоні [-180, 180], або в діапазоні [0, 180] градусів, тому при використанні 180 градусів як цільове значення, дельта між кутами ніколи (або майже ніколи) не буде рівною 180 і точно ніколи не буде більшою ніж 180. Моє рішення - це найпростіше та найшвидший обхід даної проблеми.

## Відомі проблеми

- Методи `Move` та `Rotate` в классі `Tank` використовують `Time.fixedDeltaTime`, не враховуючи звідки вони можуть бути викликані. Наприклад, якщо викликати їх в `Update` то логіка буде працювати неправильно. Одним із рішень буде передавати `float deltaTime` через параметри. Залишив як є для простоти та пришвидшення завершення проєкту.

- При використанні `AggressiveAIBehaviour`, штучний інтелект винищує сам себе при попаданні один по одному. Це дуже просто пофіксити, але я залишив щоб не витрачати час + в такому випадку гра відчувається більш живою =).

## Можливі покращення

- Використати паттерн "Object Pool" для снарядів.

- Зробити величину повороту танків (в градусах) рандомною між двома величинами (по аналогії з `RotationChangeRandomInterval`). Залишив статичною та рівною 90 градусів щоб було чітко видно що одиниці вимірювання працюють корректно.

- Класс `AIBehaviour` вийшов трохи складним для розуміння та має багаторазове створення нових корутин (корутини не є великою проблемою зараз, тож я не робив передчасних оптимізацій, але це може стати помітним у майбутньому). Для вирішення цього можно використати пакет **UniTask** і організувати роботу класу `AIBehaviour` на ньому. За допомогою цього пакету можна зробити реалізацію простіше та продуктивніше.

## Відкриті питання

- **Головне питання**. В завданні сказано `"Радіус розвороту повинен бути заданим у лінійних одиницях"` про розворот ШІ. В моєму розумінні "лінійні одиниці" це одиниці, що вимірюють довжину (метр, сантиметр, міліметр тощо), тому виникає питання як за допомогою лінійних одиниць визначити радіус розвороту (який є по суті кут)? Через те що завдання було отримано в п'ятницю та виконувалось на вихідних, відповідно не було можливості задати уточнююче питання стосовно цього моменту. Тому було вирішено тимчасово зробити радіус розвороту в градусах, тому що це просто в реалізації, максимально зрозуміло і зручно у використанні.

- В завданні сказано про повороти танку: `"Зверніть увагу, що така зміна напрямку руху має відбуватися плавно"`. Зараз зміна напрямку руху відбувається лінійно (а не дискретно). Я вважаю це достатньою умовою щоб вважати її плавною. Але якщо цього недостатньо, то збільшити "плавність" можна за допомогою функції `Mathf.SmoothDampAngle` abo `Mathf.LerpAngle` (при правильному використанні). В такому випадку функція повороту не буде лінійна, а буде мати затухання.
