# Nordcurrent - Тестове завдання (Танки)

Автор: Богдан Ніколаєв

## Коментар до проєкту

В проєкті було використано деякі рішення, які можна розцінювати як надлишкові, а саме:

- **Zenject (Dependency Injection)**. Я розумію, що для проєкту такого невеликого розміру це зовсім необов`язково, але я зробив це, щоб продемонструвати своє вміння користуватись DI. Також DI, як найкраще рішення для управлінням залежностями, ніколи не буде зайвим.

- **Сinemachine**. Використав, тому що швидко встановити, швидко налаштувати. А також щоб показати своє вміння користуватись.

- **Input System**. Для рішення даного тестового завдання можна було обійтись старою інпут системою, але на сайті Nordcurrent я побачив, що компанія створює ігри `for smartphones, tablets, and PC/Mac`, тож вирішив показати вміння користуватися новою інпут системою, за допомогою якої можна відносно зручно робити кросплатформений інпут (хоча і в моєму рішенні тестового завдання кросплатформеності немає).

Для ШІ було закладено наступну логіку при колізіях:

1. При зіткненні з будь-чим, ШІ:
   - припиняє постійний рух,
   - припиняє періодичні розвороти,
   - припиняє стріляти (у випадку виокристання`AggressiveAIBehaviour`).
  
2. При зіткненні з іншим танком, ШІ розвертається на місці на заданий в конфігі радіус (задано: 90). Після чого відновлює поведінку, що була припинена в пункті 1.

3. При зіткненні зі стіною, ШІ розвертається на місці на радіус в діапазоні [135, 179] градусів. Після чого відновлює поведінку, що була припинена в пункті 1. При таких налаштуваннях ШІ:
   - і достатньо відвертається від стіни (щоб не попасти в неї знову),
   - і присутня деяка рандомізація.

    Радіус розвертання не може дорівнювати 180, тому що всі прості способи в Unity взяття дельти кута обмежуються 180 градусами.

## Відомі проблеми

- Метод `Move` в классі `Tank` використовує `Time.fixedDeltaTime`, не враховуючи звідки він може бути викликаний. Наприклад, якщо викликати його в `Update` то логіка буде працювати неправильно. Одним із рішень буде передавати `float deltaTime` через параметри. Залишив як є для простоти та пришвидшення завершення проєкту.

- При використанні `AggressiveAIBehaviour`, штучний інтелект винищує сам себе при попаданні один по одному. Це дуже просто пофіксити, але я залишив щоб не витрачати час + в такому випадку гра відчувається більш живою =).

## Можливі покращення

- Використати паттерн "Object pool" для снарядів.

- Зробити величину повороту танків (в градусах) рандомною між двома величинами (по аналогії з `RotationChangeRandomInterval`). Залишив статичною та рівною 90 градусів щоб було чітко видно що одиниці вимірювання працюють корректно.

- Класс `AIBehaviour` вийшов трохи складним для розуміння та має багаторазове створення нових корутин (корутини не є великою проблемою зараз, тож я не робив передчасних оптимізацій, але це може буде стати помітним у майбутньому). Для вирішення цього можно використати пакет **UniTask** і організувати роботу класу `AIBehaviour` на ньому. За допомогою цього пакету можна зробити реалізацію простіше та продуктивніше.

## Відкриті питання

- В завданні сказано про повороти танку: `Зверніть увагу, що така зміна напрямку руху має відбуватися плавно`. Зараз зміна напрямку руху відбувається лінійно (а не дискретно). Я вважаю це достатньою умовою щоб вважати її плавною. Але якщо цього недостатньо, то збільшити "плавність" можна за допомогою функції `Mathf.SmoothDampAngle` abo `Mathf.LerpAngle` (при правильному використанні). В такому випадку функція повороту буде не лінійна, а буде мати затухання.
